# 4장. DB 스케일 아웃 전략

**분산을 고려한 MySQL 운용**

## **강의 11: 인덱스를 올바르게 운용하기**

분산을 고려한 MySQL 운용의 대전제

### **OS 캐시를 활용하는 이유**

- MySQL은 데이터를 가능한 한 디스크에서 직접 읽지 않고 **OS 페이지 캐시(page cache)** 를 통해 읽도록 설계되어 있다.
- 디스크의 임의 접근(seek)은 매우 느리다.
    - HDD 기준: 5~10ms
    - SSD 기준: 0.1ms
    - RAM 접근: 나노초(ns)
- 테이블 전체가 OS 캐시에 들어가 있으면 MySQL의 read 쿼리는 **사실상 메모리 엔진처럼 동작**한다.
- 데이터가 커져 캐시에 다 안 들어갈 때부터 스케일 문제가 생긴다. → 이후 강의(파티셔닝)로 이어진다.

### **정규화의 실질적 의미**

- 정규화 목적: 중복을 제거하고 테이블 크기를 줄이는 것
- 테이블 크기가 줄면 OS 캐시 적중률이 높아져 디스크 I/O가 줄어든다.
- **1바이트라도 줄이면 전체적으로 수십 MB~GB 단위의 절감이 된다.**
- 그림 4.1은 bookmark 테이블 설계 예시로, 필요한 컬럼만 유지해 테이블을 작게 유지하는 전략을 보여준다.

<img width="690" height="291" alt="image" src="https://github.com/user-attachments/assets/18a4640e-7316-4e67-aa07-44480c21eba5" />

### **인덱스의 원리 (B+트리 구조)**

- MySQL 인덱스는 **B+Tree** 구조이며, 이는 디스크 접근 최적화에 특화된 자료구조이다.
- 하나의 노드(페이지)는 보통 4KB~16KB 크기로, **디스크 페이지 크기와 일치**한다.
    
    → **디스크 I/O 1회 = 트리 노드 1개 로드**
    
- 노드 하나에 수백~수천 개의 key가 정렬된 상태로 들어간다.
- 결과적으로 트리 높이가 낮게 유지되어 디스크 I/O가 감소한다.
- 디스크 seek 횟수를 최소화하기 위해 트리 높이를 줄이고, 한 번 읽으면 많은 key를 얻는 구조가 바로 B+트리이다.

### **왜 B트리는 디스크 I/O를 극적으로 줄이는가?**

- 디스크는 sequential read는 빠르지만 random read는 매우 느리다.
- B트리는 **트리 구조로 key를 정렬하여 저장하되**, **한 노드 안에 가능한 많은 key를 넣어 random seek 횟수를 최소화한다.**
- 예시:
    - 데이터 1,000,000개
    - B트리 높이 = 3
    - 루트(1) → 중간노드(1) → 리프(1)
        
        → 총 3~4 I/O로 원하는 row 탐색 가능
        

### **explain을 통한 인덱스 검증**

- **possible_keys**: 사용할 수 있는 후보 인덱스
- **key**: 실제 선택된 인덱스
- **rows**: MySQL이 예측하는 row 검색 수
- **Extra**: Using index / Using filesort 등 중요한 힌트 포함
- 인덱스가 적용되면 rows가 매우 작게 나온다. → 쿼리 효율 향상

### **복합 인덱스의 한계**

- (a, b)에 인덱스를 만들면 a를 기준으로 탐색하고, b는 a 범위 내에서만 활용된다.
- b만 단독 검색하면 인덱스 미사용.
- 인덱스 설계의 80%는 **where 절이 실제로 어떻게 호출되는지** 패턴을 정확히 파악하는 데 달려 있다.

## **강의 12: MySQL의 분산**

확장을 전제로 한 시스템 설계 

### **Master–Slave 구조의 목적**

- 쓰기는 Master
- 읽기는 Slave
- AP 서버는 쓰기/갱신만 Master에 보내고, 읽기는 Slave 여러 대로 분산
- DB 부하 중 대부분은 읽기이므로 슬레이브 확장은 효과적
- 그림 4.6은 이 기본 구조를 시각적으로 보여준다.

<img width="695" height="540" alt="image" src="https://github.com/user-attachments/assets/a91ba17d-cb59-4227-8ca4-5de9b3468a42" />

### **레플리케이션의 동작 방식**

- Master에서 binlog가 기록된다.
- Slave는 binlog를 읽어 자신의 DB에 반영
- 결국 Slave는 Master의 event stream을 재생하는 구조
- 읽기 요청은 Slave로 분산시키면 읽기 병목이 크게 줄어든다.

### **레플리케이션의 장점**

- 읽기 처리량 확장
- 장애 분리 가능
- Master 부하 감소
- 슬레이브를 여러 대 둘 수 있어 트래픽 증가 대응 수월

### **레플리케이션의 한계**

- 쓰기 부하는 여전히 Master에 집중
- Master가 병목이면 전체 서비스 병목
- Slave lag(지연) 가능
- Slave만 늘려서는 구조적 한계 존재 → 파티셔닝이 필요해지는 지점

## **강의 13: MySQL의 스케일아웃과 파티셔닝**

### **파티셔닝이 필요한 상황**

- 테이블 크기가 커져 OS 캐시에 안 들어가는 순간부터 성능 저하 시작
- 이때부터 메모리 기반 튜닝만으로는 한계
- 테이블 단위 또는 별도 전략으로 서버별로 분할해야 함

### **테이블 분할(파티셔닝)의 기본 개념**

- 하나의 큰 테이블을 서버 여러 대에 나누어 저장
- 각 서버는 전체 데이터 중 일부만 보유
- 각 서버의 데이터 크기가 작아지므로 OS 캐시 적중률이 오르고 디스크 I/O가 줄어든다.

### **entry/tag 파티셔닝 문제와 해결**

- entry와 tag는 1:N 관계
- 서로 다른 서버에 존재하면 JOIN이 불가능

<img width="686" height="404" alt="image" src="https://github.com/user-attachments/assets/d713d28d-5805-45ff-bd34-363c3e61383b" />

- 해결 방법은 JOIN을 **두 단계의 쿼리**로 분해하는 것
    - 먼저 tag 서버에서 entry_id 목록을 받아 오고
    - entry_id 리스트로 entry 서버에서 where in (…) 조회

### **JOIN을 배제해야 하는 이유**

- JOIN은 두 테이블이 같은 DB 인스턴스에 있어야 가능
- 서버 분할된 구조에서는 JOIN 자체가 불가능
- 대규모 시스템에서 JOIN은 비용이 큰 것이 아니라 **물리적으로 불가능**한 경우가 더 많다.
- 대규모 DB는 JOIN을 쓰지 않고 동일 결과를 만들어내는 패턴을 사용해야 한다.

### **파티셔닝의 상반 관계** (장점과 단점이 공존)

### **장점**

- 트래픽 분산
- 데이터가 작아져 캐시 효율 증가
- 서버 확장성 확보
- 특정 파티션만 백업/복구 가능

### **단점**

- 운영 복잡도 증가
- JOIN 불가
- 장애 발생 시 복구 비용 상승
- 서버가 많아질수록 고장률도 높아진다.
- 어느 서버에 데이터가 있는가?를 항상 고려해야 한다.

### **서버 대수와 고장률**

- 서버 수가 늘어날수록 “항상 고장난 서버가 하나 있음”이라는 가정이 필요하다.
- 읽기 중심 서비스라 하더라도 최소 3대 이상의 슬레이브가 필요
- 이유:
    - 1대 고장 → 2대 남음
    - 남은 2대 중 한 대에서 새로운 슬레이브를 생성
    - 복제 중에 또 고장날 수 있으므로 여유 서버 필수
- 그림 4.13은 이러한 안정성을 보여주기 위한 최소 구성 예시

<img width="674" height="641" alt="image" src="https://github.com/user-attachments/assets/c91fd71a-8f70-4bf9-9ef4-0e81341f4967" />

### **파티셔닝의 본질적 결론**

- 캐시 중심 구조가 유지되는 범위에서 스케일이 잘 나온다.
- 테이블이 커지고 캐시가 깨지는 순간 → 파티셔닝이 개입
- 파티셔닝은 절대 만능이 아니다.
    - 확장성 ↑
    - 운영 복잡도도 ↑
- 파티셔닝은 데이터를 작게 나눠 **캐시 중심 설계 원칙을 유지하기 위한 수단**

## 4장. DB 스케일 아웃 전략 요약

- 인덱스(B트리)의 구조 이해 → 디스크 I/O를 극단적으로 감소시키는 기반
- OS 캐시 활용 → MySQL 성능의 핵심
- Master–Slave 구조로 읽기 확장
- 테이블 크기가 커져 캐시에 안 들어가기 시작하면 파티셔닝 필요
- 파티셔닝은 확장성과 운영 복잡성의 트레이드오프
- 대규모 MySQL 시스템의 핵심은 캐시 중심 설계를 유지하기 위한 분할 전략이다.

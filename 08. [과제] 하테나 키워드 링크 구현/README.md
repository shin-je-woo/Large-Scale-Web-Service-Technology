# 8장. [과제] 하테나 키워드 링크 구현

**응용으로 가는 길 깨닫기**

## **강의 22: [과제] 하테나 키워드 링크 만들기**

### **1. 목표**

하테나 북마크의 키워드 링크 기능을 AC법(Aho-Corasick Algorithm)으로 직접 구현하는 과제를 다룬다.

핵심 목적은 다음 세 가지를 충족하는 것이다.

- **키워드 집합을 빠르게 검색할 것**
- **의미의 중첩을 허용할 것(he 와 her 등의 겹침 포함)**
- **문장 내에서 발견된 키워드 위치를 정확히 반환할 것**

### **2. 구현 개요**

AC법의 기본 절차는 다음과 같다.

1. **Trie 생성**
    - 모든 키워드(hers, his, she …)를 문자 단위로 Trie 구조에 삽입한다.
2. **Failure Link 구성**
    - 문자열이 일치하지 않을 때 어느 노드로 점프해야 할지 “실패 링크”를 만든다.
    - 이는 prefix-suffix 기반으로 연결되며, KMP와 유사한 아이디어
3. **AC 오토마톤 완성**
    - Trie + Failure link 로 구성된 유한 상태 머신(FSM)
4. **텍스트 입력 후 match() 호출**
    - 텍스트를 한 글자씩 이동하며 자동으로 상태를 전이시키고 매칭된 키워드를 모두 반환한다.

### **3. 샘플 프로그램의 흐름**

책의 예제에서는 다음과 같이 AC 오토마톤을 만들어 테스트한다.

```perl
my $ac = My::AhoCorasick->new(qw/he hers his she/);
my $result = $ac->match($text);
```

출력은 다음처럼 “문장 내 위치(Index), 키워드 길이, 해당 키워드”가 반환된다.

```perl
pos 2, len 3 => his
pos 11, len 3 => her
...
```

즉, **문장 전체를 한 번만 스캔하면서 모든 키워드를 탐지한다.**

### **4. 구현 상세**

### **1) add_string()**

- 키워드를 Trie에 추가
- 각 문자마다 노드를 따라가며 생성
- 끝나는 지점에 “accept list”(매칭 키워드 저장)

### **2) make_failure_links()**

- BFS(너비 우선 탐색)로 Trie를 순회
- prefix-suffix가 일치하는 가장 가까운 노드로 failure link 설정
- failure link에 존재하는 accept 리스트도 상속
    
    → 중첩 키워드도 문제 없이 탐지
    

### **3) match()**

- 텍스트를 한 문자씩 탐색
- 갈 수 없는 문자면 failure link로 점프
- accept 리스트가 있으면 매칭된 키워드를 결과에 추가

### **5. 실제 과제 조건**

하테나 인턴십 과제로 제시된 실제 조건은 다음과 같다.

- **20만 단어 이상의 키워드 사전**
- 키워드가 나열된 UTF-8 텍스트 파일을 입력으로 사용
- AC 오토마톤으로 변환 후 문서 전체를 처리

즉, 실무에서도 사용할 수 있는 대용량 구현이 요구되었다.

### **6. 테스트 프로그램 작성**

하테나 내부에서는 테스트 자동화를 매우 중요하게 여긴다.

- 키워드 목록 파일(keyword.utf8.uniq.txt)
- Perl 테스트 스크립트(Test::More, Encode, Path::Class)
- **match 결과가 정확한지 자동 검증**

## **강의 23: 응답 사례와 사고방식**

### **AC 구현이 중요한 이유**

책의 저자는 코드를 작성하는 것보다 사고 과정이 더 중요하다고 강조한다.

- Trie + Failure link의 원리를 제대로 이해해야 대규모 키워드 집합을 효율적으로 처리할 수 있다.
- 단순 정규표현식으로는 20만 단어 검색 등을 감당하기 어렵다.

### **코드의 해석 포인트**

1. **add_string()의 핵심은 Trie 구성**
    - 각 노드는 다음 문자로의 edge를 가짐
    - 끝에서는 문자열 길이를 기록
2. **make_failure_links()의 핵심은 fallback 구조 형성**
    - 부모의 failure link를 기반으로 suffix 매칭을 자동 처리
    - AC가 빠른 이유의 핵심
3. **match()의 핵심은 ‘한 번의 텍스트 스캔’**
    - failure link를 이용해 백트래킹 없이 매칭
    - 효율적인 매칭이 가능한 구조

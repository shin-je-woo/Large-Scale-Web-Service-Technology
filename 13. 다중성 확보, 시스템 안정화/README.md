# 13장. 다중성 확보, 시스템 안정화

**100%에 근접한 가동률을 실현하는 원리**

## **강의 33: 다중성 확보**

### **다중화 개념**

- 24시간 365일 서비스에서 100%에 근접한 가동률을 위해 **단일 장애점(SPOF) 제거**가 핵심
- 서버가 일부 죽어도 전체 서비스는 지속되어야 함
- 서버는 언젠가 고장난다는 전제를 둔다. → 고장나면 자동으로 우회하는 구조 필요

### **AP 서버 다중화**

### **로드밸런서 중심 구조**

- AP 서버 여러 대를 두고 LB가 분산 처리
- 장점
    - 1~2대 장애는 전체 영향 없음
    - 즉시 우회 가능
    - 확장도 쉬움 (서버만 추가하면 됨)

### **그림 13.2: 페일오버 / 페일백 흐름**

<img width="699" height="410" alt="image" src="https://github.com/user-attachments/assets/f083c187-a9fa-40ee-a253-19e430b20434" />

- **정상 시**
    - LB → 여러 AP 서버로 트래픽 분산
- **장애 시**
    - 고장난 AP 서버 감지 → LB가 즉시 제외
    - 트래픽은 정상 서버로만 분산
- 사용자가 장애를 모르게 만드는 구조

### **포인트**

- AP 서버는 상태가 비슷해서 scale-out 쉽고, 다중화 난이도 낮은 영역
- 대규모 서비스는 AP 서버가 수십~수백 대로 늘어남

### **DB 서버 다중화**

### **Active / Standby 방식**

- Active DB 1대 + Standby DB 1대
- Active 장애 발생 → Standby가 즉시 승계(페일오버)

### **그림 13.3: 멀티 마스터 구성**

<img width="678" height="412" alt="image" src="https://github.com/user-attachments/assets/8989e983-19ba-4a7c-a0fb-cd5313ca9de4" />

- LVS(로드밸런서 역할)가 Virtual IP(VIP)를 통해 DB 접근 경로를 고정
- **장애 발생 흐름**
    - Active DB 장애 → Standby가 VIP를 받아 Active가 됨
    - 기존 Active는 복구 후 Standby로 다운그레이드
- VIP 덕분에 애플리케이션은 DB 전환을 몰라도 된다.

### **중요한 특징**

- DB는 AP보다 상태 변화가 많아 다중화 난이도가 훨씬 높음
- 레플리케이션 지연이 존재해, Active/Standby의 상태 정합성 관리가 핵심
- 동기식 레플리케이션이 안정성은 높지만 성능은 떨어짐
- 웹 서비스는 대부분 비동기식 + 페일오버 구조를 선택

### **스토리지 서버(MogileFS) 다중화**

### **왜 스토리지를 다중화해야 할까**

- 대용량 이미지 파일, 미디어 파일은 DB에 저장하면 성능·비용 모두 최악
- 분산 파일 시스템 필요

### **MogileFS 구조**

<img width="675" height="708" alt="image" src="https://github.com/user-attachments/assets/143cce73-134b-4b59-8d52-19a03de2a897" />

- 트래커(mogilefsd): 파일 저장 위치 관리
- 스토리지 노드(mogstored): 실제 파일 저장
- 트래커 DB(MySQL): 메타데이터 저장

### **스토리지 용량 증가**

- 2008~2010년 하테나 스토리지 증가량 실측
- 수 TB~수십 TB 단위로 빠르게 증가
- 노드만 추가하면 용량이 무한히 확장되는 구조

### **특징 요약**

- 노드 추가만으로 확장 용이
- 파일은 다중 복제 저장
- 장애가 나도 자동으로 다른 노드에서 읽기 가능
- 분산 파일 시스템 중 MogileFS는 Perl 생태계에서 널리 사용됨

## **강의 34: 시스템 안정화**

### **상반 관계(Trade-off)**

시스템 안정화는 다음의 반비례 관계 속에서 균형을 맞추는 문제다:

1. **안정성 ↔ 자원 효율**
2. **안정성 ↔ 속도**
- 캐시, 메모리, CPU 사용량이 많아질수록 속도는 빨라지지만 불안정 요인이 증가
- 안정성을 위해서는 사용량을 여유 있게 확보해야 함

### **시스템 불안정 원인**

### **1) 기능 추가**

- 새로운 기능이 늘어날수록 메모리 사용량 증가
- 특히 Perl 같은 언어는 메모리 누수가 발생하기 쉬움
- 오브젝트 생성 → 해제 안 될 경우 누수 발생

### **2) 메모리 누수**

- 크론성 코드, 오래 실행되는 백그라운드 프로세스에서 두드러짐
- 누수가 누적되면 서비스 중단 발생

### **3) 지뢰(bug-triggered faults)**

- 특정 URL·특정 입력에만 동작하는 실수
- 특정 XML 데이터처럼 edge case가 트리거가 되어 장애 발생

### **4) 사용자 액세스 패턴 변화**

- 특정 시간대 트래픽 급증 (Slashdot 효과, Digg 효과)
- 캐시가 놓친 요청이 DB에 급격히 몰려 장애 가능
- Squid 같은 캐시 서버 튜닝 필요

### **5) 데이터량 증가**

- 지속적인 데이터 증가로 인해 DB 쿼리 성능 저하
- 인덱스 크기 증가 → 메모리 부족 → 디스크 액세스 증가 → 지연 발생
- 하테나에서는 1년마다 10GB~수십 GB씩 데이터가 증가

### **6) 외부 연결 증가**

- 외부 API 호출 증가에 따라 지연·타임아웃 발생
- 외부 시스템 상태에 따라 서비스 지연으로 전파됨

### **7) 하드웨어 장애**

- 메모리 오류, HDD 고장, NIC 문제 등
- 장비 품질 문제도 잦은 장애 요인

## **강의 35: 시스템 안정화 대책**

### **실제 안정화 전략**

### **1) 적절한 여유 버퍼 유지**

- CPU/메모리 사용률을 **70% 이하로 유지**
- 나머지 30%는 장애 상황 대비를 위한 여유분
- 여유분이 없으면 작은 문제도 치명적 장애로 연결

### **2) 불안정 요인 제거**

대표적인 대상:

- SQL 부하
- 메모리 누수
- 지연 발생 코드
- 외부 API 타임아웃
- 특정 입력으로 발생하는 예외 처리 누락

### **SQL 안정화(핵심)**

- SQL이 느리면 전체 시스템이 느려진다
- 긴 SQL을 자동으로 kill하는 툴 사용
- 하테나는 2~3분 이상 걸리는 SQL 실행 시 자동 kill 처리

### **이상 동작 시의 자동 제어**

### **책의 저자가 제시하는 3가지 기법**

1. **자동 DoS 판정(F5 기반 DoS 감지)**
    - 지속 요청 증가 → 403 반환 후 차단
2. **자동 재시작(프로세스 Watchdog)**
    - Perl/OS 프로세스 감시
    - 메모리 누수나 지연 발생하면 자동 재시작
3. **자동 쿼리킬러(SQL killer)**
    - 특정 시간 이상 실행된 SQL을 강제 종료
    - DB lock 확산 방지
